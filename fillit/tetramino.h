/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tetramino.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: astripeb <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2019/05/01 10:44:25 by astripeb          #+#    #+#             */
/*   Updated: 2019/05/06 23:30:09 by astripeb         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef TETRAMINO_H
# define TETRAMINO_H

# include <sys/types.h>
# include <sys/uio.h>
# include <stdio.h>
# include <fcntl.h>
# include "libft.h"

typedef struct	s_tetramino
{
	char				**figure;
	char				octet;
	int					width;
	int					height;
	int					y;
	int					x;
	struct s_tetramino	*next;
}				t_tetramino;

//буфер на всякий случай
# define BUFF_SIZE 4096

//буфер для чтения одного тетрамино 
//4 х (4char + '\n') + '\n'
# define ONE_TET 21

//функция читает из файла по одной карте, проверяет на валидность тетрамино.
//(по идеее сюда нужно добавить формирование связного списка из валидных тетрамино)
//если один невалидный зафришить все.
//Возвращает связанный список в случае валидных карт, иначе NULL
t_tetramino	*read_file(char *filename);

//функция для валидации одной карты с тетрамино
//Возвращает фигуру в случае валидной карты, иначе NULL
char		**valid_one_tet(char *one_read_map);

//говнофункция. считает количество строк, количество символов в строке и 
//количество '#' в массиве. Возвращает 1 в случае валидной карты, иначе 0
int			basic_check(char **tab);

//говнофункция-2. проверяет правильность фигуры тетрaмино
//должно быть 4 связанных '#'
//в данном случае считаем количество сторон соприкасающихся '#'
//для ## = 8 
//    ##
//для всех остальных = 6
int		figure_check(char **tab);

//говнофункция-3. Ищет ПОСЛЕДНЕЕ вхождение '#'
//и выдает коорданату x или y в зависимости от
//переданного второго аргумента 'x' или 'y', иначе 0
int		first_x_y(char **tab, char c);

//говнофункция-4. Ищет ПОСЛЕДНЕЕ вхождение '#'
//и выдает коорданату x или y в зависимости от
//переданного второго аргумента 'x' или 'y', иначе 0
int		last_x_y(char **tab, char c);

//создает новый массив с границами фигуры
//для фигуры - ##    создаст массив figure[2][2];
//             ##
//
//для фигуры - ##    создаст массив figure[2][3];
//              ## 
//
//для фигуры - #     создаст массив figute[4][1];
//             #
//             #
//             #
char	**figure_trim(char **tab);


//создаем новый лист, куда передаем обрезанную(!) фигуру
//и размеры массива
t_tetramino	*ft_newlist(char **figure);

//добавляет в конец списка новый лист
void		ft_listadd(t_tetramino **begin, t_tetramino *new_list);

//очищает весь список, в т.ч. содержимое "figure"
void		ft_dellist(t_tetramino **begin);

//проходит по списку и изменяет у figure символы '#'
//на символы алфавита (для первого элемента 'A', для второго 'B')
void		ft_list_alpha(t_tetramino *begin);

//считает число поступивших тетрамино 
int			count_tetramino(t_tetramino *begin);

//преобразует двумерный массив тетрамино
//в char например
//##   преобразуется в 0011 0011
// ##  
char		tet_to_char(char **tet);

//вычисляет квадратный корень из числа
//возвращает ближайшее меньшее
int			ft_sqr(int nbr);

//создает двумерный массив и заполняет его "."
char		**ft_create_map(int side);

//создает считает размер карты, создает ее, запускает рекурсивную функцию
//для расстановки тетрамино, если в текущую карту не получается посместить 
//все фигурки, увеличивает размер карты
//возвращает 1 в случае успеха
int			ft_tetra_square(t_tetramino *tet);


//рекурсивная функция с перебором всех возможных вариантов размещения тетрамино
//возвращает 1 в случае успешного размещения, 0 неудачи
int			ft_tetramino(t_tetramino *tet, char **map);

//примерка текущего тетрамино на карту
//1 в случае успеха, 0 неудачи
int			ft_try_on_tet(char **map, char **figure, int y, int x);

//размещает текущий тетрамино на карту
void		ft_set_on_map(char **map, char **figure, int y, int x);

//удаляет текущий тетрамино с карты
void		ft_remove_from_map(char **map, char **figure, int y, int x);

//!!ФУНКЦИИ ДЛЯ ОТЛАДКИ. ПЕРЕД СДАЧЕЙ УДАЛИТЬ
//функция для печати двумерного массива
void	ft_print_figure(char **figure);	

//функция для итерации по списку и печaти фигур с размерами
void	ft_print_list(t_tetramino **begin);

//функция для печати октета
void	print_octet(char c);

#endif
